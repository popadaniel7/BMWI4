/*****************************************
* Project: BCM I4						 *
* Developer: Daniel Popa				 *
* Module: Timer Handler		 			 *
******************************************/
/*****************************************
*		INCLUDE PATHS					 *
******************************************/
#include "TimH.h"
#include "Rte.h"
#include "SystemManager_Types.h"
/*****************************************
*		END OF INCLUDE PATHS		     *
******************************************/
/*****************************************
*		VARIABLES					 	 *
******************************************/
/* First time stamp of the input compare value for channel three. */
uint32 Tim5_InputCompare_ValueOne_ChannelThree;
/* Second time stamp of the input compare value for channel three. */
uint32 Tim5_InputCompare_ValueTwo_ChannelThree;
/* Variable for the difference between the two time stamps for channel three. */
uint32 Tim5_Difference_ChannelThree;
/* Input capture flag variable for channel three. */
uint8 Tim5_InputCaptureFlag_ChannelThree;
/* Distance calculated for the distance traveled by the sound waves between the two input captures time stamps for channel three. */
uint8 Tim5_CalculatedDistance_ChannelThree;
/* First time stamp of the input compare value for channel four. */
uint32 Tim5_InputCompare_ValueOne_ChannelFour;
/* Second time stamp of the input compare value for channel four. */
uint32 Tim5_InputCompare_ValueTwo_ChannelFour;
/* Variable for the difference between the two time stamps for channel four. */
uint32 Tim5_Difference_ChannelFour;
/* Input capture flag variable for channel four. */
uint8 Tim5_InputCaptureFlag_ChannelFour;
/* Distance calculated for the distance traveled by the sound waves between the two input captures time stamps for channel four. */
uint8 Tim5_CalculatedDistance_ChannelFour;
/* Static variable used in timer configuration. */
STATIC TIM_ClockConfigTypeDef sClockSourceConfig2 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_MasterConfigTypeDef sMasterConfig2 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_OC_InitTypeDef sConfigOC2 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_OC_InitTypeDef sConfigOC3 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_OC_InitTypeDef sConfigOC4 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_ClockConfigTypeDef sClockSourceConfig3 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_MasterConfigTypeDef sMasterConfig3 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_ClockConfigTypeDef sClockSourceConfig4 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_MasterConfigTypeDef sMasterConfig4 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_ClockConfigTypeDef sClockSourceConfig5 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_MasterConfigTypeDef sMasterConfig5 = {0};
/* Static variable used in timer configuration. */
STATIC TIM_IC_InitTypeDef sConfigIC5 = {0};
/*****************************************
*		END OF VARIABLES				 *
******************************************/
/*****************************************
*		FUNCTIONS				 		 *
******************************************/
/* Peripheral initialization function declaration. */
StdReturnType Tim_Init(uint8 TimerChannel);
/* Peripheral de-initialization function declaration. */
StdReturnType Tim_DeInit(uint8 TimerChannel);
/* Peripheral error callback function declaration. */
VOID HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim);
/* Peripheral period elapsed callback function declaration. */
VOID HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
/* Peripheral main function declaration. */
VOID Tim_MainFunction();
/*****************************************
*		END OF FUNCTIONS				 *
******************************************/
/***********************************************************************************
* Function: HAL_TIM_IC_CaptureCallback										   	   *
* Description: Input capture callback to process information received.		 	   *
************************************************************************************/
VOID HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3)
	{
		if (Tim5_InputCaptureFlag_ChannelThree == STD_LOW)
		{
			Tim5_InputCompare_ValueOne_ChannelThree = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3);
			Tim5_InputCaptureFlag_ChannelThree = STD_HIGH;
			__HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_3, TIM_INPUTCHANNELPOLARITY_FALLING);
		}
		else if(Tim5_InputCaptureFlag_ChannelThree == STD_HIGH)
		{
			Tim5_InputCompare_ValueTwo_ChannelThree = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3);
			__HAL_TIM_SET_COUNTER(htim, 0);
			if (Tim5_InputCompare_ValueTwo_ChannelThree > Tim5_InputCompare_ValueOne_ChannelThree)
			{
				Tim5_Difference_ChannelThree = Tim5_InputCompare_ValueTwo_ChannelThree - Tim5_InputCompare_ValueOne_ChannelThree;
			}
			else if(Tim5_InputCompare_ValueOne_ChannelThree > Tim5_InputCompare_ValueTwo_ChannelThree)
			{
				Tim5_Difference_ChannelThree = (0xFFFFFFFF - Tim5_InputCompare_ValueOne_ChannelThree) + Tim5_InputCompare_ValueTwo_ChannelThree;
			}
			else
			{
				/* do nothing */
			}
			Tim5_CalculatedDistance_ChannelThree = Tim5_Difference_ChannelThree * 0.034 / 2;
			Tim5_InputCaptureFlag_ChannelThree = 0;
			__HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_3, TIM_INPUTCHANNELPOLARITY_RISING);
			__HAL_TIM_DISABLE_IT(&htim5, TIM_IT_CC3);
		}
		else
		{
			/* do nothing */
		}
	}
	else if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_4)
	{
		if (Tim5_InputCaptureFlag_ChannelFour == STD_LOW)
		{
			Tim5_InputCompare_ValueOne_ChannelFour = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_4);
			Tim5_InputCaptureFlag_ChannelFour = STD_HIGH;
			__HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_4, TIM_INPUTCHANNELPOLARITY_FALLING);
		}
		else if(Tim5_InputCaptureFlag_ChannelFour == STD_HIGH)
		{
			Tim5_InputCompare_ValueTwo_ChannelFour = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_4);
			__HAL_TIM_SET_COUNTER(htim, 0);
			if (Tim5_InputCompare_ValueTwo_ChannelFour > Tim5_InputCompare_ValueOne_ChannelFour)
			{
				Tim5_Difference_ChannelFour = Tim5_InputCompare_ValueTwo_ChannelFour - Tim5_InputCompare_ValueOne_ChannelFour;
			}
			else if(Tim5_InputCompare_ValueOne_ChannelFour > Tim5_InputCompare_ValueTwo_ChannelFour)
			{
				Tim5_Difference_ChannelFour = (0xFFFFFFFF - Tim5_InputCompare_ValueOne_ChannelFour) + Tim5_InputCompare_ValueTwo_ChannelFour;
			}
			else
			{
				/* do nothing */
			}
			Tim5_CalculatedDistance_ChannelFour = Tim5_Difference_ChannelFour * 0.034 / 2;
			Tim5_InputCaptureFlag_ChannelFour = 0;
			__HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_4, TIM_INPUTCHANNELPOLARITY_RISING);
			__HAL_TIM_DISABLE_IT(&htim5, TIM_IT_CC4);
		}
		else
		{
			/* do nothing */
		}
	}
	else
	{
		/* do nothing */
	}
}
/***********************************************************************************
* END OF HAL_TIM_IC_CaptureCallback										           *
************************************************************************************/
/***********************************************************************************
* Function: Tim_Init										   			           *
* Description: Peripheral initialization.									       *
************************************************************************************/
StdReturnType Tim_Init(uint8 TimerChannel)
{
	uint8 localValue = TimerChannel;
	switch(localValue)
	{
		case TIMER_TWO:
			htim2.Instance = TIM2;
			htim2.Init.Prescaler = 10000-1;
			htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
			htim2.Init.Period = 200-1;
			htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
			htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
			if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}
			sClockSourceConfig2.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
			if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig2) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}

			if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}
			sMasterConfig2.MasterOutputTrigger = TIM_TRGO_RESET;
			sMasterConfig2.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
			if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig2) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}
			sConfigOC2.OCMode = TIM_OCMODE_PWM1;
			sConfigOC2.Pulse = 0;
			sConfigOC2.OCPolarity = TIM_OCPOLARITY_HIGH;
			sConfigOC2.OCFastMode = TIM_OCFAST_ENABLE;
			if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC2, TIM_CHANNEL_1) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}

			if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC2, TIM_CHANNEL_2) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}

			if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC2, TIM_CHANNEL_3) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim2);
			}
			else
			{
				/* do nothing */
			}
			HAL_TIM_MspPostInit(&htim2);

			break;
		case TIMER_THREE:
			  htim3.Instance = TIM3;
			  htim3.Init.Prescaler = 10000-1;
			  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
			  htim3.Init.Period = 200-1;
			  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
			  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
			  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }
			  sClockSourceConfig3.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
			  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig3) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }

			  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }
			  sMasterConfig3.MasterOutputTrigger = TIM_TRGO_RESET;
			  sMasterConfig3.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
			  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig3) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }
			  sConfigOC3.OCMode = TIM_OCMODE_PWM1;
			  sConfigOC3.Pulse = 0;
			  sConfigOC3.OCPolarity = TIM_OCPOLARITY_HIGH;
			  sConfigOC3.OCFastMode = TIM_OCFAST_ENABLE;
			  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC3, TIM_CHANNEL_1) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }

			  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC3, TIM_CHANNEL_2) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }

			  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC3, TIM_CHANNEL_3) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }

			  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC3, TIM_CHANNEL_4) != HAL_OK)
			  {
				  HAL_TIM_ErrorCallback(&htim3);
			  }
			  else
			  {
				  /* do nothing */
			  }
			  HAL_TIM_MspPostInit(&htim3);
			break;
		case TIMER_FOUR:

			htim4.Instance = TIM4;
			htim4.Init.Prescaler = 10000-1;
			htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
			htim4.Init.Period = 1000-1;
			htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
			htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
			if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim4);
			}
			else
			{
				/* do nothing */
			}
			sClockSourceConfig4.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
			if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig4) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim4);
			}
			else
			{
				/* do nothing */
			}

			if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim4);
			}
			else
			{
				/* do nothing */
			}
			sMasterConfig4.MasterOutputTrigger = TIM_TRGO_RESET;
			sMasterConfig4.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
			if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig4) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim4);
			}
			else
			{
				/* do nothing */
			}
			sConfigOC4.OCMode = TIM_OCMODE_PWM1;
			sConfigOC4.Pulse = 999;
			sConfigOC4.OCPolarity = TIM_OCPOLARITY_HIGH;
			sConfigOC4.OCFastMode = TIM_OCFAST_DISABLE;
			if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC4, TIM_CHANNEL_3) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim4);
			}
			else
			{
				/* do nothing */
			}
			if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC4, TIM_CHANNEL_4) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim4);
			}
			else
			{
				/* do nothing */
			}
			HAL_TIM_MspPostInit(&htim4);
			break;
		case TIMER_FIVE:
			htim5.Instance = TIM5;
			htim5.Init.Prescaler = 100-1;
			htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
			htim5.Init.Period = 4294967295;
			htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
			htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
			if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim5);
			}
			else
			{
				/* do nothing */
			}
			sClockSourceConfig5.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
			if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig5) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim5);
			}
			else
			{
				/* do nothing */
			}

			if (HAL_TIM_IC_Init(&htim5) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim5);
			}
			else
			{
				/* do nothing */
			}
			sMasterConfig5.MasterOutputTrigger = TIM_TRGO_RESET;
			sMasterConfig5.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
			if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig5) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim5);
			}
			else
			{
				/* do nothing */
			}
			sConfigIC5.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
			sConfigIC5.ICSelection = TIM_ICSELECTION_DIRECTTI;
			sConfigIC5.ICPrescaler = TIM_ICPSC_DIV1;
			sConfigIC5.ICFilter = 0;
			if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC5, TIM_CHANNEL_3) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim5);
			}
			else
			{
				/* do nothing */
			}

			if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC5, TIM_CHANNEL_4) != HAL_OK)
			{
				HAL_TIM_ErrorCallback(&htim5);
			}
			else
			{
				/* do nothing */
			}
			break;
		default:
			break;

	}

	return E_OK;
}
/***********************************************************************************
* END OF Tim_Init										           	               *
************************************************************************************/
/***********************************************************************************
* Function: Adc_MainFunction										   			   *
* Description: Peripheral main function.									       *
************************************************************************************/
StdReturnType Tim_DeInit(uint8 TimerChannel)
{
	return E_OK;
}
/***********************************************************************************
* END OF HAL_ADC_ErrorCallback										           	   *
************************************************************************************/
/***********************************************************************************
* Function: Adc_MainFunction										   			   *
* Description: Peripheral main function.									       *
************************************************************************************/
VOID HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
{
	if(htim->Instance == TIM2)
	{
		SystemManager_Fault.fault[TIMER2_ERROR] = TIMER2_ERROR;
		Tim_DeInit(TIMER_TWO);
		Tim_Init(TIMER_TWO);
	}
	else if(htim->Instance == TIM3)
	{
		SystemManager_Fault.fault[TIMER3_ERROR] = TIMER3_ERROR;
		Tim_DeInit(TIMER_THREE);
		Tim_Init(TIMER_THREE);
	}
	else if(htim->Instance == TIM4)
	{
		SystemManager_Fault.fault[TIMER4_ERROR] = TIMER4_ERROR;
		Tim_DeInit(TIMER_FOUR);
		Tim_Init(TIMER_FOUR);
	}
	else if(htim->Instance == TIM5)
	{
		SystemManager_Fault.fault[TIMER5_ERROR] = TIMER5_ERROR;
		Tim_DeInit(TIMER_FIVE);
		Tim_Init(TIMER_FIVE);
	}
	else
	{
		/* do nothing */
	}
}
/***********************************************************************************
* END OF HAL_ADC_ErrorCallback										           	   *
************************************************************************************/
/***********************************************************************************
* Function: Adc_MainFunction										   			   *
* Description: Peripheral main function.									       *
************************************************************************************/
VOID Tim_MainFunction()
{
	uint32 localStateTimerTwo = HAL_TIM_Base_GetState(&htim2);
	uint32 localStateTimerThree = HAL_TIM_Base_GetState(&htim3);
	uint32 localStateTimerFour = HAL_TIM_Base_GetState(&htim4);
	uint32 localStateTimerFive = HAL_TIM_Base_GetState(&htim5);
	if(localStateTimerTwo == HAL_TIM_STATE_ERROR)
	{
		HAL_TIM_ErrorCallback(&htim2);
	}
	else if(localStateTimerThree == HAL_TIM_STATE_ERROR)
	{
		HAL_TIM_ErrorCallback(&htim3);
	}
	else if(localStateTimerFour == HAL_TIM_STATE_ERROR)
	{
		HAL_TIM_ErrorCallback(&htim4);
	}
	else if(localStateTimerFive == HAL_TIM_STATE_ERROR)
	{
		HAL_TIM_ErrorCallback(&htim5);
	}
	else
	{
		/* do nothing */
	}
}
/***********************************************************************************
* END OF HAL_ADC_ErrorCallback										           	   *
************************************************************************************/
/***********************************************************************************
* Function: Adc_MainFunction										   			   *
* Description: Peripheral main function.									       *
************************************************************************************/
VOID HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	if (htim->Instance == TIM1)
	{
		HAL_IncTick();
	}
	else
	{
		/* do nothing */
	}
}
/***********************************************************************************
* END OF HAL_ADC_ErrorCallback										           	   *
************************************************************************************/
