#include "FlsEeprom.h"
#include "math.h"
#include "string.h"
#include "cmsis_os.h"
#include "SystemManager.h"
#include "NvM.h"

void FlsEeprom_Write(uint16 page, uint16 offset, uint8 *data, uint16 size);
void FlsEeprom_Read(uint16 page, uint16 offset, uint8 *data, uint16 size);
void FlsEeprom_PageErase(uint16 page);
void FlsEeprom_WriteNum(uint16 page, uint16 offset, float  fdata);
float FlsEeprom_ReadNum(uint16 page, uint16 offset);
void FlsEeprom_FloatToBytes(uint8* ftoa_bytes_temp, float float_variable);
float FlsEeprom_BytesToFloat(uint8* ftoa_bytes_temp);
uint16 FlsEeprom_BytesToWrite(uint16 size, uint16 offset);

#define EEPROM_I2C &hi2c1
#define EEPROM_ADDR 0xA0
#define PAGE_SIZE 64
#define PAGE_NUM  512

uint8 bytes_temp[4];

uint16 FlsEeprom_BytesToWrite(uint16 size, uint16 offset)
{

	if ((size + offset) < PAGE_SIZE)
	{

		return size;

	}
	else
	{

		return PAGE_SIZE-offset;

	}

}

void FlsEeprom_Write (uint16_t page, uint16_t offset, uint8_t *data, uint16_t size)
{

	// Find out the number of bit, where the page addressing starts
	int paddrposition = log(PAGE_SIZE)/log(2);

	// calculate the start page and the end page
	uint16_t startPage = page;
	uint16_t endPage = page + ((size+offset)/PAGE_SIZE);

	// number of pages to be written
	uint16_t numofpages = (endPage-startPage) + 1;
	uint16_t pos=0;

	// write the data
	for (int i=0; i<numofpages; i++)
	{
		/* calculate the address of the memory location
		 * Here we add the page address with the byte address
		 */
		uint16_t MemAddress = startPage<<paddrposition | offset;
		uint16_t bytesremaining = bytestowrite(size, offset);  // calculate the remaining bytes to be written

		HAL_I2C_Mem_Write(EEPROM_I2C, EEPROM_ADDR, MemAddress, 2, &data[pos], bytesremaining, 1000);  // write the data to the EEPROM

		startPage += 1;  // increment the page, so that a new page address can be selected for further write
		offset=0;   // since we will be writing to a new page, so offset will be 0
		size = size-bytesremaining;  // reduce the size of the bytes
		pos += bytesremaining;  // update the position for the data buffer

		HAL_Delay (5);  // Write cycle delay (5ms)
	}
}

void FlsEeprom_FloatToBytes(uint8* ftoa_bytes_temp, float float_variable)
{

    union
	{

      float a;
      uint8_t bytes[4];

    } stmem;

    stmem.a = float_variable;

    for (uint8 i = 0; i < 4; i++)
    {

      ftoa_bytes_temp[i] = stmem.bytes[i];

    }

}

float FlsEeprom_BytesTofloat(uint8* ftoa_bytes_temp)
{

    union
	{

      float a;
      uint8_t bytes[4];

    } stmem;

    for (uint8 i = 0; i < 4; i++)
    {

    	stmem.bytes[i] = ftoa_bytes_temp[i];

    }

   float float_variable =  stmem.a;

   return float_variable;

}

void FlsEeprom_Write_Num(uint16 page, uint16 offset, float data)
{

	FlsEeprom_FloatToBytes(bytes_temp, data);

	FlsEeprom_Write(page, offset, bytes_temp, 4);

}

float FlsEeprom_Read_Num(uint16 page, uint16 offset)
{
	uint8_t buffer[4];

	FlsEeprom_Read(page, offset, buffer, 4);

	return (FlsEeprom_BytesToFloat(buffer));

}

void FlsEeprom_Read (uint16_t page, uint16_t offset, uint8_t *data, uint16_t size)
{
	int paddrposition = log(PAGE_SIZE)/log(2);

	uint16_t startPage = page;
	uint16_t endPage = page + ((size+offset)/PAGE_SIZE);

	uint16_t numofpages = (endPage-startPage) + 1;
	uint16_t pos=0;

	for (int i=0; i<numofpages; i++)
	{
		uint16_t MemAddress = startPage<<paddrposition | offset;
		uint16_t bytesremaining = bytestowrite(size, offset);
		HAL_I2C_Mem_Read_IT(EEPROM_I2C, EEPROM_ADDR, MemAddress, 2, &data[pos], bytesremaining);
		startPage += 1;
		offset=0;
		size = size-bytesremaining;
		pos += bytesremaining;
	}
}

void FlsEeprom_PageErase(uint16 page)
{

	if(osTimerIsRunning(Os_NvM_TimerHandle) == 0)
	{

		int paddrposition = log(PAGE_SIZE) / log(2);
		uint16 MemAddress = page << paddrposition;
		uint8 data[PAGE_SIZE];

		memset(data,0xff,PAGE_SIZE);
		HAL_I2C_Mem_Write_IT(EEPROM_I2C, EEPROM_ADDR, MemAddress, 2, data, PAGE_SIZE);

		NvM_DelayCounterFlag = 1;


		if(NvM_DelayCounterFlag == 1)
		{

			osTimerStart(Os_NvM_TimerHandle, 5);

		}
		else if(NvM_DelayCounterFlag == 0)
		{

			osTimerStop(Os_NvM_TimerHandle);

		}
		else
		{

			/* do nothing */

		}

	}
	else
	{

		/* do nothing */

	}

}
